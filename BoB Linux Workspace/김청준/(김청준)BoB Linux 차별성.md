### BoB Linux의 차별성
#### 방향성
- 트레이닝과 매뉴얼 기능에 중점을 둔 리눅스 배포판

- 기존의 방향은 용량이나 최적화를 위해 여러 가지 패키지를 어떻게 구성하고, 어떤 기능을 넣는 지에 대해 고민하였음
  - 하지만 이러한 방향으로는 여타 배포판과 비교에 있어서 특별한 차별성을 가지지 못함
    - 용량과 최적화의 부분에서는 훨씬 작고 빠른 리눅스가 존재
    - 보안 패키지의 구성으로는 kali나 parrot와 비교가 됨
    
- 따라서 여타 배포판에서 찾아보기 힘든 차별점인 트레이닝과 매뉴얼 한글화에 중점을 두기로 함
  - 이에 따라 우리만의 효율적인 커리큘럼을 만들고, 해당 커리큘럼을 구현하기 위해 개발을 진행
  - 매뉴얼과 다양한 실습을 지원해야하기 때문에 우리가 먼저 익히는 시간도 필요
- 학습 과정은 크게 기본 학습, 패키지 학습, 심화 학습으로 나누어짐(변경 가능)

#### 기능과 특징
##### 기본 학습
- 리눅스의 기본적인 특징과 명령어에 대해 학습
- 트레이너에 의해 메시지가 출력되며 여러 기능을 입력해보고 이에 대한 결과를 확인할 수 있도록 구성
- 특징 부분에 대해서는 권한, 계정, 파일 시스템, 패키지 관리 등에 대해서 학습 예정
- 명령어 부분에 대해서는 cd, ls, mkdir, mv, cp 등 기초 명령어와 find, grep, diff 등 응용 명령어로 구분 예정
- vim과 같은 매우 기초적인 패키지는 여기서 일정 부분 다룰 수도 있음
- 보안 패키지를 다루기 앞서서 리눅스 자체에 대한 이해도를 높이기 위한 커리큘럼에 해당됨. 
- 기본 학습 부분에서 트레이너를 따라가며 네트워크 구성, GUI 환경 구축을 스스로 할 수 있게 할 예정

##### 패키지 학습
- 기본 학습의 일정 단계 이상이 되면 이용할 수 있음
  - 먼저 기본 학습으로 기초를 다지고, apt를 사용하여 직접 패키지를 설치하게 하는 식으로 용량 문제와 교육적 측면을 동시에 잡음
- vim, wireshark, suricata, iptables, nmap, matasploit 등 다양한 패키지에 대한 학습과 실습을 할 수 있게 함
  - 각자 많이 다뤄본 패키지나 중요하다고 여겨지는 패키지를 추가하여 학습 예정
  - 일정한 순서에 따라 진행되는 순차적 학습과 자신이 배우고 싶은 패키지를 골라서 진행하는 선택적 학습 중 어떤 것을 선택할 지는 고민
    - 선택적 학습의 경우에는 선행 학습이 필요한 경우 이에 대한 지식이 없다면 따라 가기 힘듦
    - 선택적 학습 적용시 이런 점을 보완하기 위해 패키지를 선택했을 때 선행 이수 학습을 표기해주는 방법이 있음
- 도커를 이용한 BeeBox와 연계하여 공격 실습도 할 수 있게 할 예정
  
##### 어떤 보안 분야를 중심으로 심화 과정 커리큘럼을 만들지도 고민 사항
- 기본 학습과 패키지 학습 이후로 심화 과정으로 진행될 예정
- 1~2개의 분야가 적당해보임
- 2가지 분야로 나뉠 경우 두 팀으로 나누어 진행

##### 미정
- C 언어 대한 교육 진행
- 기본 학습의 후반 부에서 커널 컴파일에 대한 교육 진행

#### 생각해볼점
- 트레이닝 기능을 어떻게 구현할 것인가?
  - 일단, C언어를 통해 표준 입출력을 이용해 진행 예정
  - C언어 프로그램 상에서 입력한 명령어를 OS에 전달할 수 있는 방법을 찾아야 함
  - 예를 들어 ls를 입력하세요. 라는 출력에 대해서 ls를 입력한다면 실제 OS 상에서 ls가 입력되도록 해서 해당 디렉토리의 내용을 보여줘야 함(해결)
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CMD_SIZE 20

int run_command(char valid_cmd[])
{
        char cmd[CMD_SIZE];
        
        while(1)
        {
            scanf("%[^\n]s", cmd);
            // 입력값 검증 부분
            if(!strcmp(cmd, valid_cmd)) 
            {
                printf("OK\n"); 
                system(cmd);
                break;
            }
            else 
                printf("Please Input '%s'\n", valid_cmd); 
                // 입력 버퍼 지우기
                getchar(); 
        }
        return 0;
}

int main(void)
{
        printf("'ls' is show current directory's files\nPlease Input 'ls'\n"); 

        run_command("ls");

        return 0;
}
```
- 해당 코드를 이용해 사용자의 입력으로 리눅스의 명령어 실행 가능
- int system(const char &#42;string) : &#42;string의 값을 리눅스 명령어로 실행함
- scanf("%[^\n]s", cmd) : 개행 문자인 \n을 제외하고 모든 문자를 입력받음
- scanf 이후에 입력 값 검증을 이용해 다른 명령어의 개입을 막을 수 있음
- 원래 시스템에 손상이 가지 않게 명령어 실습 때 도커를 이용하는 방법도 있을듯

- 심화 과정에서 어떤 분야를 채택할 것인가?
  - 본인의 입장에서는 네트워크 분야가 가장 무난하게 느껴짐
  - 하지만 팀원들의 다양한 의견에 따라 커리큘럼과 심화 분야를 결정할 예정

#### Man Page
- man 명령어는 Ubuntu Base에서 'unminimize'를 한 후에 가능
- manpath를 통해 man 파일이 있는 디렉토리를 확인할 수 있음
- 동작 원리 : /usr/share/man/ 디렉토리에 있는 다양한 man 디렉토리(man1, man2 ...)에 다양한 매뉴얼들이 (이름).숫자.gz의 형식으로 생성되어 있음
  - 만약 내가 kcj.1.gz를 이 디렉토리 중 하나에 넣고 man kcj를 한다면 kcj.1.gz 안의 내용이 출력되는 방식으로 추정
  - man1 디렉토리에 있는 매뉴얼은 (이름).1.gz, man2 디렉토리에 있는 매뉴얼은 (이름).2.gz가 됨
  - 만약 man1과 man2에 같은 이름에 대한 매뉴얼이 있다면, man (이름)을 쳤을 때는 man1에 있는 매뉴얼이 보여짐
    - man (이름).2라고 치면 man2에 있는 매뉴얼이 보임
  - man2에만 있는 매뉴얼이라면 man (이름)을 입력했을 때 man2에 있는 것이 출력
- 약 3900개의 매뉴얼이 존재(Ubuntu 18.04 LTS, Ubuntu Base 기준)
  
