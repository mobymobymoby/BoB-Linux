### mkdir.c 파일
-----
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#define CMD_SIZE 20
#define BUF_SIZE 102400

void hint(char valid_cmd[])
{
	printf("'%s'를 입력하세요.", valid_cmd);
}

int run_command(char valid_cmd[])
{
	
        char cmd[CMD_SIZE];
        char d_buf[30];
        while(1)
        {
	    printf("\n");
	    getcwd(d_buf, sizeof(d_buf));
	    printf("Trainer@BoB:%s$ ", d_buf);
            scanf("%[^\n]s", cmd);
            // 입력 버퍼 삭제
            getchar();
            // 입력값 검증 부분
            if(!strcmp(cmd, valid_cmd)) 
            {
                printf("잘 입력하셨습니다.");
                // 여기서 핵심은 system 함수의 인자로 valid_cmd가 입력된다는 것임. 즉 사용자의 입력값은 사용되지 않음
                system(valid_cmd);
                break;
            }
            // 사용자가 help를 입력했을 때 힌트
            else if(!strcmp(cmd, "help"))
            {
              // 힌트 출력, 힌트는 배열 valid_cmd를 출력하여 올바른 입력 값을 유도 
            	hint(valid_cmd);
            }
            else 
            {
               printf("잘못된 명령어를 입력하셨습니다.\n힌트를 보려면 'help'를 입력해주세요.");
	    }
                
        }
        return 0;
}

int read_txt(char buf[], int n)
{
  // txt 파일을 읽어온 'buf' array에서 한 글자씩 읽어옴
  // 글자를 읽는 것은 '@'를 만나거나 파일의 끝(NULL)이 될 때 까지
  // 즉 @를 한 문단을 끝내는 플래그로 사용
	for(; buf[n] != '@' && buf[n] != '\0'; n++)
	{
		printf("%c", buf[n]);
		// 출력 버퍼 비우기. 출력 버퍼를 비우지 않으면 한 글자씩 출력되지 
		fflush(stdout);
		// 한 글자씩 출력되는 효과를 위한 sleep. 0으로 한다면 한번에 출력됨
		usleep(30000);
	}
  // 다음 배열의 인덱스로 넘어가기 위해 n+1을 리턴
	return n+1;
}
	

void training_mkdir(void)
{
	FILE *fp;
	fp = fopen("mkdir.txt", "r");
	char buf[BUF_SIZE] = {0,};
	fread(buf, sizeof(buf), 1, fp);
	
	int n = 0;
	n = read_txt(buf, n);
  // run_command의 인자로 특정 명령어를 넘겨주어 그 외의 입력값에 대해서 실행시키지 않음
	run_command("mkdir test_dir");
	n = read_txt(buf, n);
	run_command("mkdir -m 752 test_dir2");
	n = read_txt(buf, n);
	run_command("mkdir -p fruits/apple");
  n = read_txt(buf, n);
	fclose(fp);
	printf("\n");
}

void next_quit()
{
  char cmd[CMD_SIZE];
  printf("\n다음 명령어를 학습하시려면 'next'를, 종료하시려면 'quit'를 입력하세요.\n");
  scanf("%s", cmd);
  if(!strcmp(cmd, "next"))
    return;
  else
    exit(0);
}

int main()
{
  // main 함수는 training_명령어 이름()과 next_quit() 함수로 구성됨
  // 각 명령어 학습 단계를 마친 후 마지막에 트레이닝을 계속 할건지, 그만 할건지 여부를 물어본 후 입력 값에 따라 종료 또는 진행
	training_mkdir();
  next_quit();
  // training_ls(); 
  printf("이 메시지가 출력된다면 next 기능이 정상적으로 실행된 것\n");
	return 0;
}
-----

#### mkdir.txt
-----
이번에 학습할 명령어는 'mkdir'입니다. mkdir 명령어는 make directory의 약자로, '디렉토리'를 생성하는 명령어입니다.
리눅스에서 디렉토리란 윈도우 환경의 '폴더'와 비슷한 개념입니다. 디렉토리에는 '파일'이나 또 다른 디렉토리가 포함될 수 있습니다.

mkdir 명령어는 다음과 같은 형식으로 사용합니다.
$ mkdir [옵션] [생성할 디렉토리 이름]

mkdir 명령어를 입력하여 'test_dir' 디렉토리를 생성해보세요.@

mkdir의 옵션은 상당히 간단합니다. 
-m 옵션은 디렉토리를 생성할 때 권한을 설정합니다. -m xxx의 형식으로 사용하며, 아무런 값을 지정하지 않았을 때는 기본으로 755로 입력됩니다.
★리눅스 지식★
리눅스 시스템은 여러 사용자가 하나의 시스템을 사용하는 것을 전제로 만들어졌습니다.
이런 경우에 각자의 파일이 다른 사용자에 의해 변경되거나 삭제되는 것을 원하지 않을 것입니다.
그래서 고안된 것이 바로 '권한' 개념입니다.
권한은 간략하게 설명하면 '허가 받은 사람에 대해서 허가 받은 행위를 할 수 있음'입니다.
여기서 '사람'에 해당하는 것은 계정이고, '행위'에 해당하는 것은 읽기, 쓰기, 실행 동작입니다.
권한을 나타내는 방식에는 크게 2가지가 있습니다.
10자리의 문자로 나타내는 방식과, 3자리의 숫자로 나타내는 방식이 있는데, 우리가 뒤에서 배울 'ls -l' 명령어에 의해서 출력되는 것은 전자의 방식입니다.
ls -l의 명령어를 통해 나온 출력 결과가 다음과 같다고 생각해봅니다.
drwxrw-r-- kim bob
맨 앞의 'drwxrw-r--'는 권한을 나타내고, 'kim'은 소유자 이름(UID), 'bob'는 그룹 이름(GID)입니다.
여기서 10자리의 문자로 권한을 나타낸 것이 맨 앞의 'drwxrw-r--'입니다.
예를 들어 'drwxrw-r--'이라는 10자리 문자의 권한이 있다면, 크게 4부분으로 나누어 생각할 수 있습니다.
먼저 맨 앞의 'd'는 directory라는 의미입니다. 만약 해당 부분이 '-'로 되어 있다면, 그것은 '파일'이라는 것을 뜻합니다.
다음으로 나머지 9자리는 'rwx' 'rw-' 'r--'와 같이 3자리씩 끊어서 생각할 수 있습니다.
앞에서 배웠던 명령어인 'pwd'의 출력 결과가 UID와 같다면, 현재 사용자는 해당 파일의 소유자가 됩니다. 하지만 같지 않다면 '그룹' 권한이나 '전체' 권한을 적용받습니다.
자신의 그룹과 GID가 일치 한다면, 그룹 권한을 적용받게 되고, 그렇지 않다면 전체 권한을 적용받게 되는 것입니다.
만약 UID와 GID가 모두 일치한다면, UID를 우선적용 받게됩니다.
그럼 다시 위의 예시로 돌아와서, 먼저 'rwx' 부분은 '사용자(소유자,owner)' 권한입니다. 앞에서 살펴보았던 pwd로 현재 사용자를 알 수 있었습니다. 
'r'은 읽기, 'w'는 쓰기, 'x'는 실행 권한을 의미하며, 만약 'r-x'와 같이 되어 있다면 읽기와 실행 권한은 있지만, 쓰기 권한 자리가 '-'로 비워져있기 때문에 쓰기 권한은 없다는 것을 의미합니다.
다음 부분인 'rw-' 부분은 '그룹(group)' 권한 입니다. 현재 사용자가 속해있는 그룹이 해당 파일이나 디렉토리의 GID와 같다면 읽기 권한과 쓰기 권한은 있고, 실행 권한은 없음을 의미합니다.
마지막 부분인 'r--' 부분은 '전체(other)' 권한입니다. 읽기 권한만 있고 쓰기 권한이나 실행 권한이 없음을 의미합니다.
지금까지는 10자리 문자로 권한을 나타내었지만, 3자리의 숫자로 나타낼 수도 있습니다.
각 자리는 문자로 나타내는 방식과 같이 소유자, 그룹, 전체 권한으로 나뉩니다.(파일 / 디렉토리를 나타내주는 맨 앞 자리가 없어진 것이라고 생각)
읽기 권한은 숫자 '4', 쓰기 권한은 숫자 '2', 실행 권한은 숫자 '1'로 취급하고 세 권한을 더한 합을 각 자리에 표시합니다.
만약 '764'이라는 권한이 있다면, 맨 앞의 '7'은 소유자 권한 부분이며, 4+2+1이므로, 읽기, 쓰기, 실행 권한이 모두 있음을 의미합니다. 즉 문자로 표시된 'rwx' 권한과 같습니다.
다음으로 '6'은 그룹 권한 부분이며, 4+2+0이므로, 읽기 권한과 쓰기 권한은 있지만, 실행권한은 '1'이 아닌, '0'이므로 실행권한은 없습니다.
마지막으로 '4'는 전체 권한 부분이며, 4+0+0이므로 읽기 권한만 있다고 할 수 있습니다.
이러한 권한 시스템은 리눅스에서 중요한 내용이지만, 리눅스를 사용하면서 저절로 익숙해지게 되므로 억지로 외우거나 할 필요는 없습니다.

다시 mkdir -m 옵션으로 돌아와서, mkdir -m xxx의 사용법에서 'xxx'에 해당하는 것이 바로 3자리 숫자의 권한 표시 방식입니다.
즉 소유자, 그룹, 전체 권한을 숫자 형식으로 표시해주어 디렉토리를 생성할 수 있는 것입니다.
mkdir -m 명령어를 이용해 'drwxr-x-w-' 권한을 가진 디렉토리 'test_dir2'를 생성해보세요.
$ mkdir -m [권한] [생성할 디렉토리 이름]@

-p 옵션은 하위 디렉토리를 함께 생성할 때 사용합니다.
예를 들어 mkdir 명령어를 통해 '과일'이라는 디렉토리를 생성하고, 그 안에 '사과'라는 하위 디렉토리를 생성하고 싶을 때 사용합니다.
위의 예시처럼 생성하기 위해서는 'mkdir -p 과일/사과'를 입력하면 됩니다.
mkdir -p 명령어를 이용해 'fruits' 디렉토리 안에 'apple' 디렉토리를 생성해보세요.@
mkdir 명령어에 대한 학습이 끝났습니다. 
-----
