### BoB Linux의 차별성
#### 방향성
- 트레이닝과 매뉴얼 기능에 중점을 둔 리눅스 배포판

- 기존의 방향은 용량이나 최적화를 위해 여러 가지 패키지를 어떻게 구성하고, 어떤 기능을 넣는 지에 대해 고민하였음
  - 하지만 이러한 방향으로는 여타 배포판과 비교에 있어서 특별한 차별성을 가지지 못함
    - 용량과 최적화의 부분에서는 훨씬 작고 빠른 리눅스가 존재
    - 보안 패키지의 구성으로는 kali나 parrot와 비교가 됨
    
- 따라서 여타 배포판에서 찾아보기 힘든 차별점인 트레이닝과 매뉴얼 한글화에 중점을 두기로 함
  - 이에 따라 우리만의 효율적인 커리큘럼을 만들고, 해당 커리큘럼을 구현하기 위해 개발을 진행
  - 매뉴얼과 다양한 실습을 지원해야하기 때문에 우리가 먼저 익히는 시간도 필요
- 학습 과정은 크게 기본 학습 / 분야 별 학습으로 나누어짐

#### 학습 과정
##### 기본 학습
- 리눅스의 기본적인 기능과 명령어, 기초 패키지에 대해 학습
- 트레이너에 의해 메시지가 출력되며 여러 기능을 입력해보고 이에 대한 결과를 확인할 수 있도록 구성
- 기능 부분에 대해서는 권한, 계정, 파일 시스템, 텍스트 입력 등 기초 대해서 학습 예정
- 명령어 부분에 대해서는 cd, ls, mkdir, mv, cp 등 기초 명령어와 find, grep, diff 등 응용 명령어로 구분 예정
- vim과 같은 기초적인 패키지는 여기서 일정 부분 다루게 됨
- 분아 별 학습에서 보안 패키지를 다루기 앞서서 리눅스 자체에 대한 이해도를 높이기 위한 커리큘럼에 해당됨.

##### 기초 패키지 학습
- 기본 학습에 포함되며, 기본 학습의 일정 단계 이상이 되면 이용할 수 있음
  - 먼저 기본 학습으로 기초를 다짐
- 텍스트 에디터(vim, nano)와 같은 기초 패키지에 대한 학습과 실습을 할 수 있게 함

##### 분야 별 학습
- 분야는 네트워크, 리버싱, 포렌식에 우선 순위를 두고 진행될 예정
- 각자 많이 다뤄본 패키지나 중요하다고 여겨지는 패키지를 추가하여 학습 예정
- 일정한 순서에 따라 진행되는 순차적 학습과 자신이 배우고 싶은 단계를 골라서 진행하는 선택적 학습 중 어떤 것을 선택할 지는 고민
  - 선택적 학습의 경우에는 선행 학습이 필요한 경우 이에 대한 지식이 없다면 따라 가기 힘듦
  - 선택적 학습 적용시 이런 점을 보완하기 위해 단계를 선택했을 때 선행 이수 학습을 표기해주는 방법이 있음
 
##### 미정
- C 언어 대한 교육 진행
- 기본 학습의 후반 부에서 커널 컴파일에 대한 교육 진행

#### 생각해볼점
##### 트레이닝 기능을 어떻게 구현할 것인가?
- 기본 학습
  - 일단, C언어를 통해 표준 입출력을 이용해 진행 예정
  - C언어 프로그램 상에서 입력한 명령어를 OS에 전달할 수 있는 방법을 찾아야 함
  - 예를 들어 ls를 입력하세요. 라는 출력에 대해서 ls를 입력한다면 실제 OS 상에서 ls가 입력되도록 해서 해당 디렉토리의 내용을 보여줘야 함
  - 다음과 같은 코드로 구현 
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CMD_SIZE 20

int run_command(char valid_cmd[])
{
        char cmd[CMD_SIZE];
        
        while(1)
        {
            scanf("%[^\n]s", cmd);
            // 입력값 검증 부분
            if(!strcmp(cmd, valid_cmd)) 
            {
                printf("OK\n"); 
                system(cmd);
                break;
            }
            else 
                printf("Please Input '%s'\n", valid_cmd); 
                // 입력 버퍼 지우기
                getchar(); 
        }
        return 0;
}

int main(void)
{
        printf("'ls' is show current directory's files\nPlease Input 'ls'\n"); 

        run_command("ls");

        return 0;
}
```
  - 해당 코드를 이용해 사용자의 입력으로 리눅스의 명령어 실행 가능
  - int system(const char &#42;string) : &#42;string의 값을 리눅스 명령어로 실행함
  - scanf("%[^\n]s", cmd) : 개행 문자인 \n을 제외하고 모든 문자를 입력받음
  - scanf 이후에 입력 값 검증을 이용해 다른 명령어의 개입을 막을 수 있음
  - 실제로는 fgets를 사용하는 방법으로 진행 예정
  - 각 단계의 메시지는 텍스트 파일로 만들어 둔 후 C 언어 프로그램 상에서 system("cat [텍스트 파일]")으로 출력하는 방식 사용
  - 설명하는 명령어의 실행과 입력 값 검증을 해주는 함수 run_command()를 이용해서 진행
    - cd 문제 해결 필요
    
- 분야 별 학습
  - 네트워크, 리버싱, 포렌식 분야로 팀을 나눠서 진행 예정
  - 특정 패키지나 툴을 이용하기 때문에 단순 터미널을 통해 타이핑하고 따라가는 트레이닝은 불가능
    - LFS 처럼 별도의 문서(텍스트, HTML 등)를 통해 진행하는 방법
    - 한쪽에 터미널을 켜놓고 보면서 진행할 수 있는 방법
    - 특정 패키지의 경우 캡처 기능을 이용해 분석할 수 있게 하는 방법    
  - 각 분야별 커리큘럼에 대한 많은 고민이 필요

#### 매뉴얼
- 목표
  - 트레이닝 기능에서 사용하는 명령어와 패키지의 매뉴얼 한글화 
  - 이외에도 중요 기능과 패키지 위주로 매뉴얼 한글화
  - man 명령어 / HTML로 구성하여 학습 환경에 따라 탁월한 것을 선택
  - 단순 한글화가 아닌 팁이나 사용 예시들을 이해하기 쉽게 서술
  
- 기타 사항
  - man 명령어는 Ubuntu Base에서 'unminimize'를 한 후에 가능
  - manpath를 통해 man 파일이 있는 디렉토리를 확인할 수 있음
  - 동작 원리 : /usr/share/man/ 디렉토리에 있는 다양한 man 디렉토리(man1, man2 ...)에 다양한 매뉴얼들이 (이름).숫자.gz의 형식으로 생성되어 있음
    - 만약 내가 kcj.1.gz를 이 디렉토리 중 하나에 넣고 man kcj를 한다면 kcj.1.gz 안의 내용이 출력되는 방식으로 추정
    - man1 디렉토리에 있는 매뉴얼은 (이름).1.gz, man2 디렉토리에 있는 매뉴얼은 (이름).2.gz가 됨
    - 만약 man1과 man2에 같은 이름에 대한 매뉴얼이 있다면, man (이름)을 쳤을 때는 man1에 있는 매뉴얼이 보여짐
      - man (이름).2라고 치면 man2에 있는 매뉴얼이 보임
    - man2에만 있는 매뉴얼이라면 man (이름)을 입력했을 때 man2에 있는 것이 출력
  - 약 3900개의 매뉴얼이 존재(Ubuntu 18.04 LTS, Ubuntu Base 기준)
    - 중요 패키지와 트레이닝에서 다루는 것들 위주로 매뉴얼 제작 예정
